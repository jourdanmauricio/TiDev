<!DOCTYPE html>
<html lang="es">

<head>
  <sergey-import src="metas/statics" />
  <sergey-import src="metas/titles">Bucles: while y for</sergey-import>
  <link rel="stylesheet" href="/assets/css/styles.css">
  <link rel="stylesheet" href="/assets/css/menu.css">
  <link rel="stylesheet" href="/assets/css/prism.css" />
</head>

<body>
  <sergey-import src="header" />

  <main class="container">

    <h1>Fundamentos de JavaScript</h1>

    <section id="while-for">
      <h2>Bucles: while y for</h2>

      <p>Los Bucles son una forma de repetir el mismo código varias veces. </p>

      <h3>El bucle "while"</h3>

      <p>Mientras la condición condition sea verdadera, el código del cuerpo del bucle será ejecutado.</p>

      <pre>
        <code class="language-javascript">
          let i = 0;
          while (i < 3) { // muestra 0, luego 1, luego 2
            alert( i );
            i++;
          }
        </code>
      </pre>

      <p>Cada ejecución del cuerpo del bucle se llama iteración. El bucle en el ejemplo de arriba realiza 3
        iteraciones. </p>

      <h3>El bucle "do…while"</h3>

      <p>El bucle primero ejecuta el cuerpo, luego comprueba la condición, y, mientras sea un valor verdadero, la
        ejecuta una y otra vez.</p>

      <pre>
        <code class="language-javascript">
          let i = 0;
          do {
            alert( i );
            i++;
          } while (i < 3);
        </code>
      </pre>

      <p>Esta sintaxis solo debe ser usada cuando quieres que el cuerpo del bucle sea ejecutado al menos una vez sin
        importar que la condición sea verdadera. </p>

      <h3>El bucle "for"</h3>

      <p>El bucle for es similar a while con la diferencia que inicializa la variable, evalua la condición y actualiza
        la varible.</p>

      <ul>
        <li>comienzo let i = 0 Se ejecuta una vez al comienzo del bucle</li>
        <li>condición i < 3 Comprobada antes de cada iteración del bucle. Si es falsa, el bucle finaliza</li>
        <li>cuerpo alert(i) Se ejecuta una y otra vez mientras la condición sea verdadera</li>
        <li>paso i++ Se ejecuta después del cuerpo en cada iteración</li>
      </ul>

      <pre>
        <code class="language-javascript">
          for (let i = 0; i < 3; i++) { // muestra 0, luego 1, luego 2
            alert(i);
          }
        </code>
      </pre>

      <h3>Rompiendo el bucle</h3>

      <p>Como vimos anteriormente, se sale de un bucle cuando la condición se vuelve falsa. Podemos forzar una
        salida en cualquier momento usando la directiva especial break. </p>

      <pre>
        <code class="language-javascript">
        let sum = 0;
        
        while (true) {
          let value = +prompt("Ingresa un número", '');
          if (!value) break; // (*)
          sum += value;
        }
        alert( 'Suma: ' + sum );
        </code>
      </pre>

      <p>La directiva break es activada en la línea (*) si el usuario ingresa una línea vacía o cancela la entrada.
        Detiene inmediatamente el bucle, pasando el control a la primera línea después de el bucle. En este caso,
        alert.</p>

      <h3>Continuar a la siguiente iteración</h3>

      <p>La directiva continue no detiene el bucle completo. Detiene la iteración actual y fuerza al bucle a comenzar
        una nueva si la condición lo permite. Podemos usarlo si hemos terminado con la iteración actual y nos gustaría
        movernos a la siguiente.</p>

      <p>El bucle debajo usa continue para mostrar solo valores impares:</p>

      <pre>
        <code class="language-javascript">
          for (let i = 0; i < 10; i++) {
            // si es verdadero, saltar el resto del cuerpo
            if (i % 2 == 0) continue;
            alert(i); // 1, luego 3, 5, 7, 9
          }

          // Es equivalente a:

          for (let i = 0; i < 10; i++) {
            if (i % 2) {
              alert( i );
            }
          }
        </code>
      </pre>

      <h3>Etiquetas para break/continue</h3>

      <p>A veces necesitamos salirnos de múltiples bucles anidados al mismo tiempo. </p>

      <p>La declaración break <labelName> en el bucle debajo nos saca hacia la etiqueta: </p>

      <pre>
        <code class="language-javascript">
          outer: for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
              let input = prompt(`Value at coords (${i},${j})`, '');
              // Si es una cadena de texto vacía o se canceló, entonces salir de ambos bucles
              if (!input) break outer; // (*)
              // hacer algo con el valor...
            }
          }
          alert('Listo!');
        </code>
      </pre>

      <p>En el código de arriba, break outer mira hacia arriba por la etiqueta llamada outer y nos saca de dicho
        bucle. Así que el control va directamente de (*) a alert('Listo!').</p>

      <p>La directiva continue también puede usar usada con una etiqueta. En este caso, la ejecución del código salta
        a la siguiente iteración del bucle etiquetado. </p>

    </section>

    <hr>

    <section class="pagination">
      <article class="pagination-item">
        <a href="/pages/js/fundamentos/nullish-operator.html">
          <i class="material-icons">arrow_back</i>Operador Nullish
        </a>
      </article>
      <article class="pagination-item">
        <a href="/pages/js/index.html#indice">Tabla de contenido JS
          <i class="material-icons">arrow_upward</i>
        </a>
      </article>
      <article class="pagination-item">
        <a href="/pages/js/fundamentos/switch.html">Setencia Switch
          <i class="material-icons">arrow_forward</i>
        </a>
      </article>
    </section>

  </main>
  <sergey-import src="footer" />
  <script src="/assets/js/prism.js"></script>
</body>

</html>